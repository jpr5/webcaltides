<%
    # Extract common values
    uri = URI.parse(request.url)
    scheme = uri.scheme
%>

<!-- Search Form with Autocomplete -->
<%= erb :"partials/_search_form", locals: {
    variant: :main,
    placeholder: defined?(placeholder) ? placeholder : nil
} %>

<script>
document.addEventListener('DOMContentLoaded', function() {
    // Retain prior search value with Ctrl+E or Right Arrow
    function addPlaceholderToValueBehavior(input) {
        if (!input) return;
        input.addEventListener('keydown', function(e) {
            if ((e.ctrlKey && e.key === 'e') || e.key === 'ArrowRight') {
                if ((this.selectionStart === 0 && this.selectionEnd === 0 && !this.value) ||
                    (e.key === 'ArrowRight' && this.selectionStart === 0 && this.selectionEnd === 0)) {
                    e.preventDefault();
                    if (this.placeholder && !this.placeholder.startsWith('Try')) {
                        this.value = this.placeholder;
                        this.selectionStart = this.selectionEnd = this.value.length;
                        // Trigger Alpine's x-model update
                        this.dispatchEvent(new Event('input', { bubbles: true }));
                    }
                }
            }
        });
    }

    // Apply to main search
    var mainSearch = document.getElementById('searchtext');
    if (mainSearch) {
        mainSearch.focus();
        addPlaceholderToValueBehavior(mainSearch);
    }

    // Apply to sticky search
    var stickySearchInput = document.querySelector('.search-sticky input[name="searchtext"]');
    addPlaceholderToValueBehavior(stickySearchInput);

    // Sticky search on scroll (only when results are visible)
    var stickySearchBar = document.querySelector('.search-sticky');
    if (stickySearchBar) {
        var observer = new IntersectionObserver(function(entries) {
            entries.forEach(function(entry) {
                if (!entry.isIntersecting) {
                    stickySearchBar.classList.add('scrolled');
                } else {
                    stickySearchBar.classList.remove('scrolled');
                }
            });
        }, { threshold: 0, rootMargin: '-80px 0px 0px 0px' });

        var heroSection = document.querySelector('.hero-marker');
        if (heroSection) {
            observer.observe(heroSection);
        }

        // Scroll to results section on page load when results are present
        var results = document.getElementById('results');
        if (results) {
            results.scrollIntoView({ behavior: 'smooth', block: 'start' });
        }
    }

    // Helper to format and display time, storing raw ISO for re-formatting
    function setTimeElement(el, isoTime) {
        if (!el) return;
        el.dataset.isoTime = isoTime;
        el.textContent = '@ ' + window.tzUtils.formatTime(isoTime);
    }

    // Re-render all times when timezone preference changes
    window.addEventListener('tz-changed', function() {
        document.querySelectorAll('.data-time[data-iso-time]').forEach(function(el) {
            el.textContent = '@ ' + window.tzUtils.formatTime(el.dataset.isoTime);
        });
    });

    // Lazy load station data with IntersectionObserver
    // Prefetch cards 1 viewport height ahead of current scroll position
    function loadCardData(card) {
        if (card.dataset.loaded) return; // Already loaded
        card.dataset.loaded = 'true';

        var type = card.dataset.stationType;
        var id = card.dataset.stationId;

        fetch('/api/stations/' + type + '/' + encodeURIComponent(id) + '/next')
            .then(function(response) { return response.json(); })
            .then(function(data) {
                var preview = card.querySelector('.data-preview-content');
                if (!preview) return;

                if (data.error || !data.events || data.events.length === 0) {
                    preview.querySelectorAll('.data-time').forEach(function(el) {
                        el.textContent = 'N/A';
                    });
                    return;
                }

                if (type === 'tides') {
                    data.events.forEach(function(event, index) {
                        var slotClass = index === 0 ? '.data-tide-1' : '.data-tide-2';
                        var slot = preview.querySelector(slotClass);
                        if (!slot) return;

                        var labelEl = slot.querySelector('.data-label');
                        var timeEl = slot.querySelector('.data-time');
                        var highIcon = slot.querySelector('.data-icon-high');
                        var lowIcon = slot.querySelector('.data-icon-low');

                        if (labelEl) labelEl.textContent = event.type;
                        setTimeElement(timeEl, event.time);

                        if (event.type === 'High') {
                            if (highIcon) highIcon.classList.remove('hidden');
                            if (lowIcon) lowIcon.classList.add('hidden');
                        } else {
                            if (highIcon) highIcon.classList.add('hidden');
                            if (lowIcon) lowIcon.classList.remove('hidden');
                        }
                    });

                    if (data.events.length < 1) {
                        var slot1 = preview.querySelector('.data-tide-1 .data-time');
                        if (slot1) slot1.textContent = 'N/A';
                    }
                    if (data.events.length < 2) {
                        var slot2 = preview.querySelector('.data-tide-2 .data-time');
                        if (slot2) slot2.textContent = 'N/A';
                    }
                } else if (type === 'currents') {
                    var hasSlack = false;
                    var nextMaxCurrent = null;

                    data.events.forEach(function(event) {
                        if (event.type === 'Slack') {
                            hasSlack = true;
                            var slackEl = preview.querySelector('.data-slack .data-time');
                            setTimeElement(slackEl, event.time);
                        } else if (event.type === 'Flood' || event.type === 'Ebb') {
                            if (!nextMaxCurrent) {
                                nextMaxCurrent = event;
                            }
                        }
                    });

                    if (nextMaxCurrent) {
                        var maxEl = preview.querySelector('.data-max-current');
                        if (maxEl) {
                            var labelEl = maxEl.querySelector('.data-label');
                            var timeEl = maxEl.querySelector('.data-time');
                            if (labelEl) labelEl.textContent = nextMaxCurrent.type;
                            setTimeElement(timeEl, nextMaxCurrent.time);
                        }
                    } else {
                        var maxTimeEl = preview.querySelector('.data-max-current .data-time');
                        if (maxTimeEl) maxTimeEl.textContent = 'N/A';
                    }

                    if (!hasSlack) {
                        var slackEl = preview.querySelector('.data-slack .data-time');
                        if (slackEl) slackEl.textContent = 'N/A';
                    }
                }
            })
            .catch(function(err) {
                console.error('Failed to load station data:', err);
                var preview = card.querySelector('.data-preview-content');
                if (preview) {
                    preview.querySelectorAll('.data-time').forEach(function(el) {
                        el.textContent = 'N/A';
                    });
                }
            });
    }

    // Debounced lazy loading - only load cards after scrolling stops
    // This prevents loading cards that are just scrolled past quickly
    function setupDebouncedLoader() {
        var scrollTimeout = null;
        var SCROLL_DEBOUNCE_MS = 150; // Wait 150ms after scrolling stops

        // Check which cards are currently visible and load them
        function loadVisibleCards() {
            var viewportTop = window.scrollY;
            var viewportBottom = viewportTop + window.innerHeight;
            var margin = 100; // Small margin to catch cards just entering view

            var loaded = 0, skipped = 0, outOfView = 0;
            document.querySelectorAll('.station-card[data-station-type]').forEach(function(card) {
                if (card.dataset.loaded) { skipped++; return; } // Already loaded

                var rect = card.getBoundingClientRect();
                var cardTop = rect.top + window.scrollY;
                var cardBottom = cardTop + rect.height;

                // Check if card is within viewport (with small margin)
                var isVisible = cardBottom >= (viewportTop - margin) &&
                                cardTop <= (viewportBottom + margin);

                if (isVisible) {
                    loaded++;
                    loadCardData(card);
                } else {
                    outOfView++;
                }
            });
            console.log('loadVisibleCards: viewport=' + viewportTop + '-' + viewportBottom + ', loaded=' + loaded + ', skipped=' + skipped + ', outOfView=' + outOfView);
        }

        // Debounced scroll handler
        function onScroll() {
            if (scrollTimeout) {
                clearTimeout(scrollTimeout);
            }
            scrollTimeout = setTimeout(loadVisibleCards, SCROLL_DEBOUNCE_MS);
        }

        // Listen for scroll events
        window.addEventListener('scroll', onScroll, { passive: true });

        // Also load on resize (debounced)
        window.addEventListener('resize', onScroll, { passive: true });

        // Initial load for cards already in view
        loadVisibleCards();
    }

    // Delay setup to avoid triggering during initial scroll animation
    setTimeout(setupDebouncedLoader, 500);
});
</script>

<% if defined?(tide_results) && defined?(current_results) %>
<!-- Hero marker for sticky detection -->
<div class="hero-marker"></div>
</div></header>

<!-- Sticky Search Bar (appears when scrolling results) -->
<div class="search-sticky hidden md:block">
    <div class="max-w-2xl mx-auto px-4">
        <%= erb :"partials/_search_form", locals: {
            variant: :sticky,
            placeholder: defined?(placeholder) ? placeholder : nil
        } %>
    </div>
</div>

<!-- Results Section -->
<main id="results" class="bg-navy-950 pt-6 md:pt-8 pb-12 md:pb-16 scroll-mt-20">
    <div class="max-w-6xl mx-auto px-4">

        <!-- Search summary -->
        <div class="text-center mb-10 animate-fade-up">
            <p class="text-slate-400"
               x-data="{ distanceUnit: window.unitUtils.getDistanceUnit() }"
               @units-changed.window="distanceUnit = window.unitUtils.getDistanceUnit()">
                <% case how
                   when 'by' %>
                    Showing results for "<span class="text-white font-medium"><%= tokens.join(" ") %></span>"
                <% when 'near' %>
                    Stations near <span class="text-white font-medium"><%= tokens.join(", ") %></span>
                <% end %>
                <% if radius && radius > 0 %>
                    within <span class="text-ocean-400"><%= radius %><span x-text="distanceUnit"></span></span>
                <% end %>
                <span class="text-slate-600">Â·</span>
                <span class="text-slate-500"><%= tide_results.count + current_results.count %> found</span>
            </p>
        </div>

        <% if tide_results.count > 0 %>
        <!-- Tide Stations Section -->
        <section class="mb-16 animate-fade-up animation-delay-100">
            <div class="flex items-center gap-3 mb-6">
                <div class="flex items-center justify-center w-10 h-10 rounded-full bg-ocean-500/10 border border-ocean-500/20">
                    <svg class="w-5 h-5 text-ocean-400" fill="currentColor" viewBox="0 0 24 24">
                        <path d="M17.66 8L12 2.35 6.34 8A8.02 8.02 0 004 13.64c0 2 .78 4.11 2.34 5.67a7.99 7.99 0 0011.32 0c1.56-1.56 2.34-3.67 2.34-5.67 0-2.15-.86-4.2-2.34-5.64zM6 14c.01-2 .62-3.27 1.76-4.4L12 5.27l4.24 4.38C17.38 10.77 17.99 12 18 14H6z"/>
                    </svg>
                </div>
                <h2 class="text-2xl md:text-3xl font-semibold text-white">Tide Stations</h2>
                <span class="text-slate-500 text-sm">(<%= tide_results.count %>)</span>
            </div>

            <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4 md:gap-6">
                <% tide_results.each_with_index do |group, index| %>
                <%
                    r = group.primary  # Use primary station from group
                    has_alternatives = group.has_alternatives?
                    alternatives = group.alternatives || []
                    # Build base URL path only (no query string) - will be completed dynamically
                    uri.path = "/tides/"
                    uri.query = nil
                    uri.scheme = "webcal"
                    webcal_base = uri.to_s
                    uri.scheme = scheme
                    https_base = uri.to_s
                    card_id = "tide_#{r.id}"
                    # Build sources array for all cards (needed for dynamic URLs)
                    sources_json = ([r] + alternatives).map { |s|
                        { id: s.id, provider: s.provider.upcase, publicId: s.public_id, url: s.url }
                    }.to_json
                    # Static map URL (Google Maps, Geoapify, or nil for placeholder)
                    map_url = static_map_url(lat: r.lat, lon: r.lon, accent_color: '0x0ea5e9')
                %>
                <%= erb :"partials/_station_card", locals: {
                    type: :tide,
                    station: r,
                    index: index,
                    theme: { accent: "ocean", text: "text-white" },
                    map_url: map_url,
                    webcal_base: webcal_base,
                    https_base: https_base,
                    has_alternatives: has_alternatives,
                    alternatives: alternatives,
                    sources_json: sources_json
                } %>
                <% end %>
            </div>
        </section>
        <% end %>

        <% if current_results.count > 0 %>
        <!-- Current Stations Section -->
        <section class="animate-fade-up animation-delay-200">
            <div class="flex items-center gap-3 mb-6">
                <div class="flex items-center justify-center w-10 h-10 rounded-full bg-seafoam-500/10 border border-seafoam-500/20">
                    <svg class="w-5 h-5 text-seafoam-400" fill="currentColor" viewBox="0 0 24 24">
                        <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-1 17.93c-3.95-.49-7-3.85-7-7.93 0-.62.08-1.21.21-1.79L9 15v1c0 1.1.9 2 2 2v1.93zm6.9-2.54c-.26-.81-1-1.39-1.9-1.39h-1v-3c0-.55-.45-1-1-1H8v-2h2c.55 0 1-.45 1-1V7h2c1.1 0 2-.9 2-2v-.41c2.93 1.19 5 4.06 5 7.41 0 2.08-.8 3.97-2.1 5.39z"/>
                    </svg>
                </div>
                <h2 class="text-2xl md:text-3xl font-semibold text-white">Current Stations</h2>
                <span class="text-slate-500 text-sm">(<%= current_results.count %>)</span>
            </div>

            <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4 md:gap-6">
                <% current_results.each_with_index do |group, index| %>
                <%
                    r = group.primary  # Use primary station from group
                    has_alternatives = group.has_alternatives?
                    alternatives = group.alternatives || []
                    # Build base URL path only (no query string) - will be completed dynamically
                    uri.path = "/currents/"
                    uri.query = nil
                    uri.scheme = "webcal"
                    webcal_base = uri.to_s
                    uri.scheme = scheme
                    https_base = uri.to_s
                    card_id = "current_#{r.bid}"
                    # Build sources array for all cards (needed for dynamic URLs)
                    # Include depth, publicId, and url for current stations to support depth selector
                    sources_json = ([r] + alternatives).map { |s|
                        { id: s.bid, provider: s.provider.upcase, depth: s.depth&.to_i, publicId: s.bid, url: s.url }
                    }.to_json
                    # Compute unique depths and check if we need a depth selector
                    all_sources = [r] + alternatives
                    unique_depths = all_sources.map { |s| s.depth&.to_i }.compact.uniq.sort
                    has_multiple_depths = unique_depths.length > 1
                    # Static map URL (Google Maps, Geoapify, or nil for placeholder)
                    map_url = static_map_url(lat: r.lat, lon: r.lon, accent_color: '0x2dd4bf')
                %>
                <%= erb :"partials/_station_card", locals: {
                    type: :current,
                    station: r,
                    index: index,
                    theme: { accent: "seafoam", text: "text-navy-900" },
                    map_url: map_url,
                    webcal_base: webcal_base,
                    https_base: https_base,
                    has_alternatives: has_alternatives,
                    alternatives: alternatives,
                    sources_json: sources_json,
                    has_multiple_depths: has_multiple_depths
                } %>
                <% end %>
            </div>
        </section>
        <% end %>

        <% if tide_results.count == 0 && current_results.count == 0 %>
        <!-- No results -->
        <div class="text-center py-16 animate-fade-up">
            <div class="inline-flex items-center justify-center w-16 h-16 rounded-full bg-navy-800/50 mb-4">
                <svg class="w-8 h-8 text-slate-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"/>
                </svg>
            </div>
            <h3 class="text-xl text-slate-400 mb-2">No stations found</h3>
            <p class="text-slate-500">Try a different search term or GPS coordinates</p>
        </div>
        <% end %>

    </div>
</main>

<!-- Dummy elements to close the header tags opened in layout -->
<header class="hidden"><div class="hidden">
<% end %>
